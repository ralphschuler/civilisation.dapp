name: AI Triage

on:
  issues:
    types:
      - opened
      - edited
      - reopened
  pull_request:
    types:
      - opened
      - edited
      - reopened
      - ready_for_review
      - synchronize

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  triage_issue:
    if: github.event_name == 'issues' && secrets.OPENAI_API_KEY != ''
    runs-on: ubuntu-latest
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
    steps:
      - name: Check OpenAI configuration
        id: ai-inputs
        run: |
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "::warning::OPENAI_API_KEY secret is not configured. Skipping issue triage." >&2
            echo "enabled=false" >> "$GITHUB_OUTPUT"
          else
            echo "enabled=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Prepare issue context
        id: issue-context
        if: steps.ai-inputs.outputs.enabled == 'true'
        uses: actions/github-script@v8
        with:
          github-token: ${{ github.token }}
          script: |
            const body = context.payload.issue.body ?? 'No description provided.';
            const labels = (context.payload.issue.labels || []).map((label) => label.name);
            core.setOutput('body', body);
            core.setOutput('labels', labels.length ? labels.join(', ') : 'none');

      - name: Run OpenAI triage for issue
        if: steps.ai-inputs.outputs.enabled == 'true'
        id: openai-issue
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.OPENAI_API_KEY }}
          prompt: |
            You are the autonomous triage bot for the repository ${{ github.repository }}.
            Analyse the following GitHub issue and decide which of the predefined labels should be applied.
            Respond with a compact JSON object that follows this exact TypeScript type without extra commentary:
            {
              "labels": string[],
              "comment": string
            }

            Use only labels from this list:
              - type:bug
              - type:feature
              - type:question
              - type:maintenance
              - area:frontend
              - area:contracts
              - area:automation
              - priority:low
              - priority:medium
              - priority:high
              - status:needs-info
              - status:ready

            Always include at most one label per namespace (e.g. only one priority:*).
            Add "status:needs-info" and ask clarifying questions in the comment when the report is unclear or missing reproduction steps.
            If no action is needed, return an empty array for labels and an empty string for comment.

            Issue title: ${{ github.event.issue.title }}
            Issue body:
            ---
            ${{ steps['issue-context'].outputs.body }}
            ---

            Existing labels on the issue: ${{ steps['issue-context'].outputs.labels }}

      - name: Apply triage decisions
        if: steps.ai-inputs.outputs.enabled == 'true'
        uses: actions/github-script@v8
        env:
          OPENAI_JSON: ${{ steps['openai-issue'].outputs['final-message'] }}
        with:
          github-token: ${{ github.token }}
          script: |
            const payload = process.env.OPENAI_JSON;

            if (!payload) {
              core.info('No AI decision to apply.');
              return;
            }

            let parsed;
            try {
              parsed = JSON.parse(payload);
            } catch (error) {
              core.warning(`Could not parse AI response: ${error}`);
              core.debug(payload);
              return;
            }

            const labels = Array.isArray(parsed.labels)
              ? parsed.labels.filter(Boolean)
              : [];
            const comment = typeof parsed.comment === 'string' ? parsed.comment.trim() : '';

            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                labels,
              });
            }

            if (comment) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: comment,
              });
            }

  triage_pr:
    if: github.event_name == 'pull_request' && secrets.OPENAI_API_KEY != ''
    runs-on: ubuntu-latest
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
    steps:
      - name: Check OpenAI configuration
        id: ai-inputs
        run: |
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "::warning::OPENAI_API_KEY secret is not configured. Skipping PR triage." >&2
            echo "enabled=false" >> "$GITHUB_OUTPUT"
          else
            echo "enabled=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Gather changed files
        id: changed-files
        if: steps.ai-inputs.outputs.enabled == 'true'
        uses: actions/github-script@v8
        with:
          github-token: ${{ github.token }}
          result-encoding: string
          script: |
            const files = await github.paginate(
              github.rest.pulls.listFiles,
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number,
                per_page: 100,
              },
            );

            return files
              .map((file) => {
                const changeCount =
                  typeof file.changes === 'number' ? `, ${file.changes} changes` : '';
                return `${file.filename} (${file.status}${changeCount})`;
              })
              .join('\n');

      - name: Run OpenAI triage for PR
        if: steps.ai-inputs.outputs.enabled == 'true'
        id: openai-pr
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.OPENAI_API_KEY }}
          prompt: |
            You are the autonomous PR triage bot for ${{ github.repository }}.
            Based on the pull request description and changed files, decide which labels should be applied
            and whether a maintainer-facing comment is needed.
            Respond with JSON matching this type and do not include any other text:
            {
              "labels": string[],
              "comment": string
            }

            Allowed labels:
              - status:needs-review
              - status:needs-info
              - status:ready
              - scope:frontend
              - scope:contracts
              - scope:tooling
              - scope:automation
              - priority:low
              - priority:medium
              - priority:high
              - tests:missing
              - tests:included

            Apply exactly one status:* label.
            If the PR does not touch test files and should include tests, add "tests:missing".
            If it contains changes under contracts/ ensure you also set scope:contracts, etc.
            Leave the comment empty when no additional guidance is necessary.

            Pull request title: ${{ github.event.pull_request.title }}
            Pull request body:
            ---
            ${{ github.event.pull_request.body }}
            ---

            Changed files:
            ${{ steps['changed-files'].outputs.result || 'No files detected.' }}

      - name: Apply PR triage decisions
        if: steps.ai-inputs.outputs.enabled == 'true'
        uses: actions/github-script@v8
        env:
          OPENAI_JSON: ${{ steps['openai-pr'].outputs['final-message'] }}
        with:
          github-token: ${{ github.token }}
          script: |
            const payload = process.env.OPENAI_JSON;

            if (!payload) {
              core.info('No AI decision to apply.');
              return;
            }

            let parsed;
            try {
              parsed = JSON.parse(payload);
            } catch (error) {
              core.warning(`Could not parse AI response: ${error}`);
              core.debug(payload);
              return;
            }
            const labels = Array.isArray(parsed.labels)
              ? parsed.labels.filter(Boolean)
              : [];
            const comment = typeof parsed.comment === 'string' ? parsed.comment.trim() : '';

            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                labels,
              });
            }

            if (comment) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: comment,
              });
            }
